1：[如何理解执行上下文](#jump1);<br />
2：[如何理解作用域链](#jump2);<br />
3: [如何理解原型链](#jump3);<br />
4: [什么是闭包](#jump4);

### <span id="jump1">1:如何理解执行上下文-（包含了变量、作用域链和this）</span>
执行上下文可以理解为当前代码的运行环境。<br />
在 JavaScript 中，运行环境主要包含了**全局环境**和**函数环境**。<br />
在 JavaScript 代码运行过程中，最先进入的是全局环境，而在函数被调用时则进入相应的函数环境。
执行上下文是以栈（一种 LIFO 的数据结构）的方式被存放起来的，我们称之为执行上下文栈

在 JavaScript 代码开始执行时，首先进入全局环境，此时全局上下文被创建并入栈，之后当调用函数时则进入相应的函数环境，此时相应函数上下文被创建并入栈，
当处于栈顶的执行上下文代码执行完毕后，则会将其出栈。<br />

[JavaScript 之深入理解执行上下文](https://www.jianshu.com/p/0d2fb2f2f52c "Title")
### <span id="jump2">2:如何理解作用域链</span>
当前环境向父级一层一层查找变量的过程
### <span id="jump3">3:如何理解原型链</span>
每个函数都拥有一个prototype属性，每个函数实例对象都拥有一个__proto__属性，而这个属性指向了函数的prototype，<br />
当我们访问实例对象的属性或者方法时，会先从自身构造函数中查找，如果没有就通过__proto__去原型中查找，这个查找的过程我们称之为原型链。

![原型链](./img/yuanxinglian.png)

[说说原型（prototype）、原型链和原型继承](https://zhuanlan.zhihu.com/p/35790971)

### <a id="jump4">4:什么是闭包</a>
简单理解就是**函数中嵌套函数**。我们都知道局部变量我们是无法访问的，但是通过闭包可以做到。

闭包的定义即：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包

优点：<br/>
    1.希望一个变量长期存储在内存中。<br/>
    2.避免全局变量的污染。<br/>
    3.私有成员的存在。<br/>
缺点：<br />
1.常驻内存，增加内存使用量。<br />
2.使用不当会很容易造成内存泄露。

### 5:export和export default的区别？
`export default  xxx<br/>
 import xxx from './'
 
 export xxx <br />
 import {xxx} from './'`<br />
 
 1.export default 用于规定模块的默认对外接口<br/>
 2.很显然默认对外接口只能有一个，所以 export default 在同一个模块中只能出现一次<br/>
 3.export default只能直接输出，不能先定义再输出。
 
### 6:继承有哪些方法
一：借助构造函数实现继承<br/>
原理就是在Child里面,把Parent的this指向改为是Child的this指向,从而实现继承
```
function Parent(name){
    this.name=name;
    }
    Parent.prototype.saiHi=function(){
        console.log("hello")
    }
    function Child(name,age,gender){
        Parent.call(this,name)
        this.age=age;
        this.gender=gender;
    }
    let child=new Child("王磊",20,"男")
    console.log(child.name);// 王磊
    child.sayHi(); // Uncaught TypeError:child.sayHi is not a function
```
*缺点*:只能解决**属性**的继承,使用属性的值不重复,但是父级类别的方法不能继承

二：借助原型链实现继承
原理就是把Child的原型改为是Parent的实例,从而实现继承
```
        function Parent(name,gender){
            this.name=name;
            this.gender=gender;
            this.list=[1,2,3]
        }
        Parent.prototype.eat=function(){
            console.log("晚餐时间到")
        }
        function Child(age){
            this.age=age;
        }
        Child.prototype=new Parent("李白","男");
        var child=new Child(20);
        var child2=new Child(30);
        child.eat();
        console.log(child.list,child2.list);// [1,2,3] [1,2,3]
        child.list.push(4)
        console.log(child.list);// [1,2,3,4]        
        console.log(child2.list);// [1,2,3,4]
```  
缺点:因为Child的原型对象都是New Parent,所以实例化出来的对象的属性都是一样的,而且Parent上面的引用类型只要有一个实例对象修改了,其他也会跟着修改.因为他们原型对象都是共用的<br/>
三：组合型<br/>
```
        function Person(school){
            this.school=school;
        }
        Person.prototype.skill=function(){
            console.log("学习");
        }
        function Student(school,name,age,gender){
            Parent.call(this,school);
            this.name=name;
            this.age=age;
            this.gender=gender;
        }
        Student.prototype=Person.prototype;
        let student=new Student("广铁一中","王菲菲",14,"女");
        console.log(Student.prototype===Person.prototype)
        console.log(student.constructor)
```
缺点:父类的原型对象调用了两次,没有必要,而且student实例的构造函数是来自于Person
四：组方式优化
```
        function Parent(name,play){
            this.name=name;
            this.play=play;
        }
        function Child(name,play,age){
            Parent.call(this,name,play);
            this.age=age;
        }
        Child.prototype=Object.create(Parent.prototype);// 隔离了父类和子类的构造函数,父类的添加到了__proto__属性上
        Child.prototype.constructor=Child
        let child=new Child("张三","玩",20);
        let child2=new Child("李四","吃",10)
       
        console.log(child.constructor)
```
*你必须得理解Object.create()方法的使用,他创建的对象是在原型上面的*
